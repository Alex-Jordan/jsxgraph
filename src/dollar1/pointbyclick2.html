<html>
<head>
    <title>JSXGraph example</title>
    <link rel="stylesheet" type="text/css" href="../distrib/jsxgraph.css" />
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script type="text/javascript" src="ndollar.js"></script>
    <script type="text/javascript" src="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js"></script>
</head>
<body>

<h2>Create a point with simple clicks. Uses jQuery via Google CDN.</h2>

<div style="width:800px">
    <div id="jxgbox" class="jxgbox" style="width:800px; height:800px; float:left; background-image:url(medsand.gif);"></div>
</div>

<div id="debug" style="display:block;"></div>

<script type="text/javascript">
    /* <![CDATA[ */
	var isline = false;
	var _r = new NDollarRecognizer(true);
	var points_screen = new Array();
    (function() {
        var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-10, 10, 10, -10], axis:false, grid:true}),
            //
            // bestFit, the best-fitting circle or line is found by least-squares fitting.
            //
            bestFit = function(p, testOnly) {
                var i, angle, co, si, 
                    delta = 0.8, 
                    
                    M = [], y = [], MT, B, c, z, n, d, xm, ym, r;
 
                // Having constructed the points, we can fit a circle 
                // through the point set, consisting of n points.
                // The (n times 3) matrix consists of
                //   x_1, y_1, 1
                //   x_2, y_2, 1
                //      ...
                //   x_n, y_n, 1
                // where x_i, y_i is the position of point p_i
                // The vector y of length n consists of
                //    x_i*x_i+y_i*y_i 
                // for i=1,...n.
                
                n = p.length;
                for (i=0;i<n;i++) {
                    M.push([p[i].length ? p[i][0] : p[i].X(), p[i].length ? p[i][1] : p[i].Y(), 1.0]);
                    y.push(M[i][0]*M[i][0]+M[i][1]*M[i][1]);
                }
 
                // Now, the general linear least-square fitting problem
                //    min_z || M*z - y||_2^2
                // is solved by solving the system of linear equations
                //    (M^T*M) * z = (M^T*y)
                // with Gauss elimination.
                MT = JXG.Math.transpose(M);
                B = JXG.Math.matMatMult(MT, M);
                c = JXG.Math.matVecMult(MT, y);
                if (Math.abs(JXG.Math.Numerics.det(B))<Math.sqrt(JXG.Math.eps)) {
                    isLine = true;
                } else {
                    z = JXG.Math.Numerics.Gauss(B, c);
                    xm = z[0]*0.5;
                    ym = z[1]*0.5;                   // xm, ym : center of the circle
                    r = Math.sqrt(z[2]+xm*xm+ym*ym); // r: radius
                    d = JXG.Math.Geometry.distance(points[0], points[points.length-1]);

                }
                    if (!testOnly) 
                        board.create('circle', [[xm,ym],r]);
                
                return isLine;
            }, // End of bestFit
            
            getMouseCoords = function(e) {
                if (!document.all) { // not IE
                    var em = document.createEvent('MouseEvents'), i = 0;

                    if(e.targetTouches) {  // always false
                        em.initMouseEvent('mousedown', true, false, this.containerObj, 0,
                            e.targetTouches[i].screenX, e.targetTouches[i].screenY,
                            e.targetTouches[i].clientX, e.targetTouches[i].clientY,
                            false, false, false, false, 0, null);
                        
                        e = em;
                    }
                }
                var cPos = board.getRelativeMouseCoordinates(e),
                    absPos = JXG.getPosition(e),
                    dx = absPos[0]-cPos[0],
                    dy = absPos[1]-cPos[1];

                return new JXG.Coords(JXG.COORDS_BY_SCREEN, [dx, dy], board);
            },
            mousedown,
            points = [];


        var draftcurve = board.create('curve',[[0],[0]],{curveType:'plot', strokeWidth:14, opacity:0.15});
        draftcurve.updateDataArray = function() {
            if (points.length<=0) return;
            var p = JXG.Math.transpose(points);
            this.dataX = p[0];
            this.dataY = p[1];
        };
        draftcurve.highlight = function() {};
        draftcurve.noHighlight = function() {};
        
        var down = function(e) {
            var coords = getMouseCoords(e),
                i;

            if(e.shiftKey)
                return;

            mousedown = true;
            for(i in board.objects) {
                if(JXG.isPoint(board.objects[i]) && board.objects[i].hasPoint(coords.scrCoords[1], coords.scrCoords[2])) {
                    mousedown = false;
                    break;
                }
            }

            if(!mousedown)
                return;

            points = [];
			points_screen = [];
            points.push(coords.usrCoords.slice(1));
			points_screen.push(coords.scrCoords.slice(1));
            draftcurve.prepareUpdate().update().updateRenderer();
            // prevent accidental text selection
            if (e && e.preventDefault) {
                e.preventDefault();
            } else {
                window.event.returnValue = false;
            }
        };

        var move = function(e, m) {
            if(mousedown) {
                points.push(getMouseCoords(e).usrCoords.slice(1));
				points_screen.push(getMouseCoords(e).scrCoords.slice(1));
                draftcurve.prepareUpdate().update().updateRenderer();
				var result = _r.Recognize(new Array(points_screen),true,true);
				if(result.Name == "circle")
                	draftcurve.setProperty({strokeColor:'blue'});
				else if(result.Name =="line")
					draftcurve.setProperty({strokeColor:'green'});
					
				
            }
        };

        var up = function(e){
            if((e.fromTouch && points.length==1) || (!e.fromTouch && points.length<=15))
                board.create('point', points[0], {fillColor:'#000000', fillOpacity:0.8, strokeWidth:0, size:4 });
            else
                var result = _r.Recognize(new Array(points_screen),true,true); 
				if(result.Name == 'circle')
					bestFit(poins_screen,false);
				else if(result.Name =='line')
					board.create('line',[points[0],points[points.length-1]]);
				
            mousedown = false;
            points = [];
        };

        board.addHook(down, 'mousedown');
        board.addHook(move, 'mousemove');
        board.addHook(up, 'mouseup');
    })();

    /* ]]> */
</script>
</body>
</html>
