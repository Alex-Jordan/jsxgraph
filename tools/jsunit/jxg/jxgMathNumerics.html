<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>JXG.Math Tests</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../css/jsUnitStyle.css">
<script type="text/javascript" src="../app/jsUnitCore.js"></script>
<script type="text/javascript" src="../../../src/loadjsxgraph.js"></script>
<script type="text/javascript">

    // Helper function. Used in testNeville and testLagrangePolynomial
    function makeFakeFunction(P, i, j) {
        return function() {
            return P[i][j];
        };
    }


    function testGauss() {
        var A = [[1, 1, 1], [0,-2,-3], [0,-6,-8]],
            Atest = [[1, 1, 1], [0,-2,-3], [0,-6,-8]],
            Apivot = [[0, 1, 0], [1, 0, 0], [0, 0, 1]],
            Asing = [[0, 0, 0], [0, 1, 0], [0, 0, 1]],
            b = [0, 1, 3],
            excep;

        assertArrayEquals("JXG.Math.Numerics.Gauss without pivoting", [0.5, -0.5, 0], JXG.Math.Numerics.Gauss(A, b));
        assertArrayEquals("JXG.Math.Numerics.Gauss is not allowed to change the given Matrix", Atest, A);
        assertArrayEquals("JXG.Math.Numerics.Gauss is not allowed to change the given right hand side vector", [0, 1, 3], b);
        assertArrayEquals("JXG.Math.Numerics.Gauss with pivoting", [1, 0, 3], JXG.Math.Numerics.Gauss(Apivot, b));

        try {
            JXG.Math.Numerics.Gauss(Asing, b);
            fail("JXG.Math.Numerics.Gauss with a singular matrix should throw an Error() exception");
        } catch (e) {}

        try {
            JXG.Math.Numerics.Gauss(A, [1, 0]);
            fail("JXG.Math.Numerics.Gauss should throw an exception if dimensions of the matrix and right hand side differ");
        } catch (e) {}
    }

    function testBackwardSolve() {
        var A = JXG.Math.identity(3,3),
            b = [4, 3, 2];

        A[0][0] = 2;
        A[0][2] = 1;
        assertArrayEquals("JXG.Math.Numerics.backwardSolve, incorrect result, no input change", [1, 3, 2], JXG.Math.Numerics.backwardSolve(A, b));
        assertArrayEquals("JXG.Math.Numerics.backwardSolve changed input but it wasn't allowed to", [4,3,2], b);

        assertArrayEquals("JXG.Math.Numerics.backwardSolve, incorrect result, input change allowed", [1, 3, 2], JXG.Math.Numerics.backwardSolve(A, b, true));
    }

    function testJacobi() {
        var A = [[2,0,0],[0,4,0],[0,0,8]];
        assertArrayEquals("JXG.Math.Numerics.Jacobi, incorrect result", [A, JXG.Math.identity(3)], JXG.Math.Numerics.Jacobi(A));
    }

    function NewtonCotes() {
        var f = function(x) { return sin(x); },
            interval = [0, 2*Math.PI];

        assertEquals("JXG.Math.Numerics.NewtonCotes, incorrect result", 0, JXG.Math.Numerics.NewtonCotes(interval, f));
    }

    function testNewton() {
        var f = function(x) { return x-2; };
        assertTrue("JXG.Math.Numerics.Newton, incorrect result", Math.abs(2 - JXG.Math.Numerics.Newton(f, 0)) < JXG.Math.eps);
    }

    function testSplineDef() {
        var x = [1, 2, 3],
            y = [1, 2, 3];

        assertArrayEquals("JXG.Math.Numerics.splineDef, incorrect result", [0, 0, 0], JXG.Math.Numerics.splineDef(x, y));
    }

    function testSplineEval() {
        var x = [1, 2, 3],
            y = [1, 2, 3],
            F = JXG.Math.Numerics.splineDef(x, y);

        assertEquals("JXG.Math.Numerics.splineEval, incorrect result (Given Number)", 1.5, JXG.Math.Numerics.splineEval(1.5, x, y,F));
        assertNaN("JXG.Math.Numerics.splineEval outside the evaluation area should return NaN", JXG.Math.Numerics.splineEval(0.5, x, y,F));
        assertArrayEquals("JXG.Math.Numerics.splineEval, incorrect result (Given Array)", [1.5, 2.5], JXG.Math.Numerics.splineEval([1.5, 2.5], x, y,F));
    }

    function testGeneratePolynomialTerm() {
        var coeff = [5.12345, 4.12345, 3, 2, 1],
            deg = 4,
            varname = 'x',
            prec = 3;

            assertEquals("JXG.Math.Numerics.generatePolynomialTerm, incorrect result", '(1.00)*x<sup>4</sup> + (2.00)*x<sup>3</sup> + (3.00)*x<sup>2</sup> + (4.12)*x + (5.12)', JXG.Math.Numerics.generatePolynomialTerm(coeff, deg, varname, prec));
    }

    function testLagrangePolynomial() {
        // This will look a little bit strange. We need points, but all we need in lagrangePolynomial() from those points
        // is the X() and Y() method. Hence, we're faking some points.
        var p = [], P = [[1,1],[2,3],[3,2]], i, lagrange;

        for(i=0; i<P.length; i++) {
            p[i] = {
                elementClass: JXG.OBJECT_CLASS_POINT,
                X: makeFakeFunction(P, i, 0),
                Y: makeFakeFunction(P, i, 1)
            };
        }

        lagrange = JXG.Math.Numerics.lagrangePolynomial(p);
        assertEquals("JXG.Math.Numerics.lagrangePolynomial, incorrect result", 2.375, lagrange(1.5));
        assertEquals("JXG.Math.Numerics.lagrangePolynomial, incorrect result", 2.375, lagrange(1.5, false));
    }

    function testNeville() {
        // same as in testLagrangePolynomial()
        var p = [], P = [[1,1],[2,3],[3,2]], i, neville;

        for(i=0; i<P.length; i++) {
            p[i] = {
                elementClass: JXG.OBJECT_CLASS_POINT,
                X: makeFakeFunction(P, i, 0),
                Y: makeFakeFunction(P, i, 1)
            };
        }

        neville = JXG.Math.Numerics.Neville(p);
        assertEquals("JXG.Math.Numerics.Neville, incorrect result from xfct", 1, neville[0](0, true));
        assertEquals("JXG.Math.Numerics.Neville, incorrect result from xfct", 1, neville[0](0, false));
        assertEquals("JXG.Math.Numerics.Neville, incorrect result from yfct", 1, neville[1](0, true));
    }

    function testRegressionPolynomial() {
        // same as in testLagrangePolynomial() & testNeville
        var p = [], P = [[1,2,3], [1,3,2]], i,
            regressionPoints, regressionArrays,
            fakeSlider = {
                elementClass: JXG.OBJECT_CLASS_POINT,
                Value: function() {
                    return 2;
                }
            };

        for(i=0; i<P[0].length; i++) {
            p[i] = {
                elementClass: JXG.OBJECT_CLASS_POINT,
                X: makeFakeFunction(P, 0, i),
                Y: makeFakeFunction(P, 1, i)
            };
        }

        regressionPoints = JXG.Math.Numerics.regressionPolynomial(2, p);
        regressionArrays = JXG.Math.Numerics.regressionPolynomial(fakeSlider, P[0], P[1]);

        assertRoughlyEquals("JXG.Math.Numerics.regressionPolynomial, Array of Points, Degree number, incorrect result", 2.375, regressionPoints(1.5), JXG.Math.eps);
        assertRoughlyEquals("JXG.Math.Numerics.regressionPolynomial, Two Arrays, Degree slider, incorrect result", 2.375, regressionArrays(1.5), JXG.Math.eps);
    }

    function testD() {
        var f = function(x) {
            return x*x;
        },
        df = JXG.Math.Numerics.D(f);

        assertRoughlyEquals("JXG.Math.Numerics.D, incorrect result", 2, df(1), JXG.Math.eps);
    }

    function testRiemann() {

    }

    function testRiemannSum() {

    }

    function testRungeKutta() {
        
    }

    function testBezier() {

    }

</script>
</head>

<body>
<h1>JXG.Math Tests</h1>

<p>This page contains tests for the JSXGraph JXG.Math functions. To see them, take a look at the source.</p>
</body>
</html>
