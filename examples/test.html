<html>
<head>
   <title>JSXGraph example</title>
   <link rel="stylesheet" type="text/css" href="../distrib/jsxgraph.css" />
   <script type="text/javascript" src="../src/loadjsxgraph.js"></script>
   <script type="text/javascript" src="../src/Roulette.js"></script>
</head>
<body>
<h2>Roulettes</h2>
<form>
<input type="button" value="start" onclick="rol.start()">
<input type="button" value="stop" onclick="rol.stop()">
<input type="button" value="one step" onclick="rol.rolling()">
</form>
<div id="jxgbox" class="jxgbox" style="width:1000px; height:500px;"></div>
<div id="debug" style="display:block;"></div>
<script type="text/javascript">
    /* <![CDATA[ */


//JXG.Options.text.defaultDisplay = 'internal';
var brd = JXG.JSXGraph.initBoard('jxgbox', {boundingbox:[-4.5,8,40,-5.5], axis:true, keepaspectratio:true});
if (true) {
    //var l = brd.create('curve', [function(t) { return t;}, function(t){ return 1;}], {strokeWidth:6});
    var l = brd.create('curve', [function(t) { return t;}, function(t){ return 0.5*Math.cos(t);}], {strokeWidth:6});
    //var A = brd.create('glider',[-4,1,l]);
    var P = brd.create('point',[0,0.5],{name:'P', trace:true});
    var C = brd.create('point',[0,2],{name:'C'});
} else {
    var l = brd.create('curve', [function(t) { return 4*Math.cos(t);}, function(t){ return 4*Math.sin(t);},0,2*Math.PI], 
            {strokeWidth:6});
    //var A = brd.create('glider',[4,0,l]);
    var P = brd.create('point',[4,0],{name:'P'});
    var C = brd.create('point',[1.2,0],{name:'C'});
}
var c = brd.create('curve',[
                    function(t){var d = P.Dist(C);
                                var beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);
                                t += beta;
                                return C.X()+d*Math.cos(t);
                    },
                    function(t){var d = P.Dist(C);
                                var beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);
                                t += beta;
                                return C.Y()+d*Math.sin(t);
                    },
                    0,2*Math.PI],
                    {strokeWidth:6, strokeColor:'green'});
var B = brd.create('glider',[0,2,c],{name:'B', color:'blue',trace:false});
brd.create('segment',[C,B],{color:'black'}); 
/*
var createRoulette = function(c1, c2, start_c1, stepsize, time, pointlist) {
    var alpha = 0,
        t1 = start_c1,
        t2 = JXG.Math.Numerics.root(
                function(t) { 
                    var c1x = c1.X(t1),
                        c1y = c1.Y(t1),
                        c2x = c2.X(t),
                        c2y = c2.Y(t);
                    return (c1x-c2x)*(c1x-c2x) + (c1y-c2y)*(c1y-c2y);
                },
                0),
        t1_new = 0.0, t2_new = 0.0, 
        rotation = brd.create('transform',[function(){ return alpha;}, 
                                           function(){ return c1.X(t1);},
                                           function(){ return c1.Y(t1);}], 
                                          {type:'rotate'}),
        linDist = function(t) {
                var mx = c1.X(t1),
                    my = c1.Y(t1),
                    c1x = mx - c1.X(t1_new),
                    c1y = my - c1.Y(t1_new),
                    c2x = mx - c2.X(t),
                    c2y = my - c2.Y(t);
                return (c1x*c1x+c1y*c1y) - (c2x*c2x+c2y*c2y);
            },   
        interval = null; 

    this.rolling = function(){
        t1_new = t1+stepsize;
        t2_new = JXG.Math.Numerics.root(linDist, t2+stepsize);
        alpha = -JXG.Math.Geometry.rad(
                    [c1.X(t1_new),c1.Y(t1_new)],
                    [c1.X(t1),c1.Y(t1)],
                    [c2.X(t2_new),c2.Y(t2_new)]);
        rotation.applyOnce(pointlist);
        brd.update();
        t1 = t1_new;
        t2 = t2_new;
    };
    
    this.start = function() {
        if (time>0) {
            interval = setInterval(this.rolling, time);
        }
        return this;
    };
    
    this.stop = function() {
        clearInterval(interval);
        return this;
    };
    return this;
};
*/
var rol = JXG.Math.Numerics.createRoulette(l, c, 0, Math.PI/20, 100, [C,P,B]); //.start();
//rollen();

/*    
var p1 = brd2.create('point', [0,0], {style:6, name:'p1'});
var s = brd2.create('slider', [[-1,-1],[2,-1],[0,Math.PI/2,2*Math.PI]], {name:'angle'});

var sq = [];
sq[0] = brd2.create('point', [0,-2], {style:10});
sq[1] = brd2.create('point', [2,2], {style:10});
sq[2] = brd2.create('point', [1,1], {style:10});
sq[3] = brd2.create('point', [2,-2], {style:10});
var pol = brd2.create('polygon',sq);

var rot = brd2.create('transform', [function(){return s.Value();},p1], {type:'rotate'});
rot.bindTo(sq);
brd2.create('group',[p1].concat(sq));

var p2 = brd2.create('point', [2,0], {name:'p2', style:7,trace:false});
rot.bindTo(p2);
brd2.update();  // why update? 
*/
/*
JXG.Options.text.useASCIIMathML = true;
JXG.Options.point.face = '<>';
JXG.Options.point.size = 10;
JXG.Options.text.fontSize = 18;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 5, 10, -1], axis:false});
var dataArr = [4,1,3,2,5,7,1.5,2];
//var a = board.createElement('chart', dataArr, {chartStyle:'bar',width:0.6,labels:dataArr});
var t = board.createElement('point',[7,1]);
var t2 = board.createElement('text',[1,1,'sum_(i=1)^n (x^i)']);
*/

/* ]]> */
</script>
<form><input type="button" value="Export SVG" onClick="document.getElementById('out').value = XMLSerializer().serializeToString(brd.renderer.svgRoot);"> 
<br>
<textarea id="out" rows=10 cols=60>
</textarea>
</form>

</body>
</html>
