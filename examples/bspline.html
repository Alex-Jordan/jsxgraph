<html>
<head>
   <title>JSXGraph example</title>
   <link rel="stylesheet" type="text/css" href="../distrib/jsxgraph.css" />
   <script type="text/javascript" src="../src/loadjsxgraph.js"></script>
</head>
<body>
  <h2>B-splines</h2>
  <div id="jxgbox" class="jxgbox" style="width:600px; height:600px;"></div>
  <div id="debug" style="display:block;"></div>
  <form><input type="button" value="add point" 
               onclick="p.push(board.createElement('point',[Math.random()*8-4,Math.random()*8-4]));board.update();"></form>
   <script type="text/javascript">
    /* <![CDATA[ */

        var board, i, p, col;
        board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox:[-4,4,4,-4], keepaspectratio:true, axis:true});
        //board.options.curve.doAdvancedPlot = false;
        p = [];
        for (i=0;i<8;i++) {
            if (i%1==0) {
                col = 'red';
            } else {
                col = 'blue';
            }
            p.push(board.createElement('point',[Math.random()*8-4,Math.random()*8-4],{/*id:'p'+i,*/strokeColor:col,fillColor:col}));
        }
    JXG.addEvent(p[0].rendNode, 'mouseover', function(){alert('Hallo');}, p[0]);
    JXG.addEvent(p[0].rendNode, 'mouseout', function(){}, p[0]);
    p[0].hasPoint = function(){return false; };

JXG.Math.Numerics.bspline = function(points, order) {
    var knots = [], N = [];
    
    var _knotVector = function(n,k){
            var j, kn = [];
            for (j=0;j<n+k+1;j++) {
                if (j<k) {
                    kn[j] = 0.0;
                } else if (j<=n) {
                    kn[j] = j-k+1;
                } else {
                    kn[j] = n-k+2;
                }
            }
            return kn;
        };

    var _evalBasisFuncs = function(t,kn,n,k,s) {
            var i,j,s,a,b,den,
                N = [];
                
            if (kn[s]<=t && t<kn[s+1]) {
                N[s]=1; 
            } else {
                N[s]=0; 
            }
            for (i=2;i<=k;i++) {
                for (j=s-i+1;j<=s;j++) {
                    if (j<=s-i+1||j<0) {
                        a = 0.0;
                    } else {
                        a = N[j];
                    }
                    if (j>=s) {
                        b = 0.0;
                    } else {
                        b = N[j+1];
                    }
                    den = kn[j+i-1]-kn[j];
                    if (den==0) {
                        N[j] = 0;
                    } else {
                        N[j] = (t-kn[j])/den*a;
                    }
                    den = kn[j+i]-kn[j+1];
                    if (den!=0) {
                        N[j] += (kn[j+i]-t)/den*b;
                    }
                }
            }    
            return N;
        };


    return [function(t,suspendedUpdate) {
                var len = points.length, 
                    y, i, j, s, a, b,
                    n = len-1,
                    k = order;
                    
                if (n<=0) return NaN;
                if (n+2<=k) k = n+1;
                if (t<=0) return points[0].X(); 
                if (t>=n-k+2) return points[n].X();
                
                knots = _knotVector(n,k);
                s = Math.floor(t)+k-1;
                N = _evalBasisFuncs(t,knots,n,k,s);
                
                y = 0.0;
                for (j=s-k+1;j<=s;j++) {
                    if (j<len && j>=0) y += points[j].X()*N[j];
                }
                return y;
            },
            function(t,suspendedUpdate) {
                var len = points.length, 
                    y, i, j, s, a, b,
                    n = len-1,
                    k = order;
                    
                if (n<=0) return NaN;
                if (n+2<=k) k = n+1;
                if (t<=0) return points[0].Y(); 
                if (t>=n-k+2) return points[n].Y();

                knots = _knotVector(n,k);
                s = Math.floor(t)+k-1;
                N = _evalBasisFuncs(t,knots,n,k,s);
                
                y = 0.0;
                for (j=s-k+1;j<=s;j++) {
                    if (j<len && j>=0) y += points[j].Y()*N[j];
                }
                return y;
            }, 
            0, function() {return points.length-1;}
           ];
};



        var c = board.createElement('curve', JXG.Math.Numerics.bspline(p,4), {strokecolor:'blue', strokeWidth:2}); 
        //var c = board.createElement('curve', bspline, {strokecolor:'blue', strokeWidth:2}); 

        
  /* ]]> */
  </script>
</body>
</html>
