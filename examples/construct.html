<!--<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html>-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
   <title>JSXGraph example</title>
   <link rel="stylesheet" type="text/css" href="../distrib/jsxgraph.css" />
    <script type="text/javascript" src="../src/loadjsxgraph.js"></script>
    <!--<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.91/jsxgraphcore.js"></script>-->
    <!--<script type="text/javascript" src="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore-0.82.js"></script>-->
    <script type="text/javascript" src="../src/GeonextReader.js"></script>
    <script type="text/javascript" src="../src/CanvasRenderer.js"></script>
<style type="text/css">
</style>    
</head>
<body id="body">
<h1 id="x1"  onClick="JXG.JSXGraph.freeBoard(brd)">Playground</h1>
<div id='jxgbox' class='jxgbox' style='width:700px; height:500px;'></div>
<div id="debug" style='width:600px; height:200px; background-color:#eee'></div>

<script type='text/javascript'>
//JXG.Options.text.display = 'internal';
//JXG.Options.renderer = 'canvas';
var brd = JXG.JSXGraph.initBoard('jxgbox', {boundingbox:[-4,4,4,-4], keepaspectratio:true, showNavigation:true});

if (true) {
    var plot = brd.create('functiongraph',["sin(x)"]);
    var plot2 = brd.create('curve', [function(phi) { return phi*0.9; }, [0,0]], {curveType:'polar'});
    var p1 = brd.create('point',[0, 0], {face:'[]', withLabel:false});
    var c1 = brd.create('circle',[p1, [2, 0]], {fillColor:'#ff000044', fillOpacity:1});
    var p2 = brd.create('point',[-3, 1], {withLabel:false, name:'x2', labelColor:'#00000010'});
    var l1 = brd.create('line',[p1, p2]);
    var l2 = brd.create('line',[-3,1,1]);
    var tu = brd.create('turtle', [0,0]);
    tu.fd(3).rt(90).fd(5).rt(90).fd(3).rt(90).fd(5);

    var g1 = brd.create('glider',[2,1, tu]);
    var s1 = brd.create('segment',[g1, p2]);
    var p3 = brd.create('midpoint',[s1], {trace:false});
} else {
    p1 = brd.createElement('point', [0, 0]);
    p2 = brd.createElement('point', [6, -1]);
    c1 = brd.createElement('circle', [p1, 2]);
    c2 = brd.createElement('circle', [p2, 1.5]);
    g1 = brd.createElement('glider', [6, 3, c1], {name:"D"});
    c3 = brd.createElement('circle', [g1, 4]);
    g2 = brd.createElement('intersection', [c2,c3,0], {name: "I"});
    p3 = brd.createElement('midpoint', [g1,g2], {name:"T",trace:false});

    g3 = brd.createElement('otherintersection', [c2,c3,g2], {name: "I_2"});
    p4 = brd.createElement('midpoint', [g1,g3], {name:"T_2",trace:true});
}

if (true) {
var cu = brd.create('curve',[[0],[0]], {strokeColor:'black', strokeWidth:3});
cu.updateDataArray = function(){
    var i, step, t, el, pEl, x, y, v,
        le = 100, 
        from = false,
        glider = g1, tracepoint = p3,
        savePos = glider.position, 
        slideObj = glider.slideObject,
        mi = slideObj.minX(),
        ma = slideObj.maxX();

    step = (ma-mi)/le;
    this.dataX = [];
    this.dataY = [];
    if (slideObj.elementClass!=JXG.OBJECT_CLASS_CURVE) {   // closed path
        le++;
    }
    for (i=0; i<le; i++) {
        t = mi + i*step;
        if (slideObj.type==JXG.OBJECT_TYPE_TURTLE) {
            v = slideObj.evalCoords(t);
            x = v[1];
            y = v[2];
        } else {
            x = slideObj.X(t)/slideObj.Z(t);
            y = slideObj.Y(t)/slideObj.Z(t);
        }
        glider.setPositionDirectly(JXG.COORDS_BY_USER, x, y);
        from = false;
        for (el in this.board.objects) {
            pEl = this.board.objects[el];
            if (pEl==glider) { 
                from = true;
            }
            if (!from) {
                continue;
            }
            if (!pEl.needsRegularUpdate) { continue; }
            pEl.needsUpdate = true;
            pEl.update(true);
            if (pEl==tracepoint) { 
                break;
            }
        }
        this.dataX[i] = tracepoint.X();
        this.dataY[i] = tracepoint.Y();
    }
    glider.position = savePos;
    for (el in this.board.objects) {
        pEl = this.board.objects[el];
        if (pEl==glider) { 
            from = true;
        }
        if (!from) {
            continue;
        }
        if (!pEl.needsRegularUpdate) { continue; }
        pEl.needsUpdate = true;
        pEl.update(true).updateRenderer();
        if (pEl==tracepoint) { 
            break;
        }
    }
};
}

brd.update();

</script> 
</body>
</html>
